# JAVA

### [Q] 자바의 특징
[A] 자바는 객체지향 언어로 캡슐화, 상속, 다형성, 추상화의 특징을 갖습니다. JVM을 통해 운영체제에 상관없이 독립적으로 실행되며 가비지 컬렉터를 통해 사용하지 않는 메모리를 자동으로 관리합니다. 또한 다양한 오픈소스 라이브러리와 API, 멀티스레드 등을 제공합니다. 

<br>

### [Q] JAVA의 장단점 
[A] Java는 객체지향 언어로 코드의 모듈화, 재사용성 및 유지보수에 용이하며 JVM을 통해 운영체제에 독립적으로 동작하며 풍부한 라이브러리와 프레임워크를 가지고 있다는 장점이 있지만 다중 상속, 타입에 엄격하고 제약이 많으며 고급 언어로 실행 시간 성능이 다른 저급 언어보다 느릴 수 있습니다. 

<br>

### [Q] JVM이란 (Java Virtual Machine)
[A]  JVM이란 자바 가상머신으로 스택기반으로 동작하며 컴파일 된 클래스 파일을 운영체제에 상관 없이 다양한 환경에서 실행 가능하게 합니다. 또한 프로세스에서 더 이상 사용하지 않는 할당된 메모리를 자동으로 해제 해 주는 가비지 컬렉터 기능을 수행합니다. 

<br>

### [Q] 가비지컬렉터
[A] 가비지 컬렉터는 프로그래밍 언어에서 메모리 관리를 담당하는 중요한 컴포넌트 중 하나로 주로 메모리 누수를 방지하고 더 이상 사용되지 않는 객체를 자동으로 제거하여 메모리를 최적화하는 데 사용됩니다. 

<br>

### [Q] 자바 메모리 구조
[A] 자바 프로그램이 실행 될 때 메모리는 여러 영역으로 나뉘어 관리되며 JVM에서 제어하고 관리 합니다. 메모리 영역은 크게 메서드영역, 힙 영역, 스택 영영으로 나눌 수 있습니다. 메서드 영역은 클래스 파일, 메서드, 스태틱 변수, 상수 풀 등과 같은 클래스와 관련된 정보를 저장하는 영역이며 힙 영역은 동적으로 생성된 객체와 배열이 저장되는 곳입니다. 마지막으로 스택 영역은 메서드 호출과 관련된 데이터, 로컬 변수 및 메서드 호출 스택이 저장됩니다.

<br>

### [Q] 자바 어플리케이션 실행과정
[A] Java 어플리케이션은 Java 소스 코드를 작성한 후 컴파일하여 바이트 코드로 변환하고, 이후 Java 가상 머신(JVM)에서 실행됩니다.

<br>

### [Q] 기본형과 참조형
[A] 기본형 데이터 타입은 java에 내장되어 있는 단순한 데이터 타입으로 주로 숫자, 문자 또는 논리 값을 저장하기 위해 사용되며 실제 값을 직접 스택 메모리에 저장합니다. 참조형 데이터 타입은 객체를 다루기 위한 데이터 타입으로 객체를 가리키는 주소를 힙 메모리에 저장합니다. 

<br>

### [Q] ‘==’과 ‘equals’의 차이
[A] '=='는 참조 비교 방식으로 같은 주소를 가리키고 있는지 확인합니다. 'equlas()'는 내용 비교 방식으로 두 객체의 값이 같은지를 확인합니다. 

<br>

### [Q] 객체란, 클래스, 메서드, 변수
[A] 객체는 현실 세계의 모든 사물을 의미합니다. 이를 자바와 같은 프로그래밍 언어로 표현하기 위해 클래스 형태로 설계하게 됩니다. 클래스는 객체의 속성을 인스턴스 변수로, 객체의 동작은 클래스의 메서드로 표현 합니다. 이때 변수는 속성의 값,상태를 저장하게 되며 메서드는 객체의 동작과 기능을 담당합니다. 

<br>

### [Q] 생성자 
[A] 객체를 생성할 때 호출되는 특별한 메서드로 생성자는 객체의 초기화 작업을 수행하며, 객체가 사용되기 전에 반드시 호출되어야 합니다. 명시적으로 생성자를 만들지 않아도 default로 만들어지며, 생성자는 파라미터를 다르게하여 오버로딩할 수 있습니다.

<br>


### [Q] final 키워드 VS 상수
[A] final과 상수는 변경되지 않는 값이라는 공통점이 있습니다. 하지만 final 변수는 런타임 시에 초기화 되지만 상수는 선언시 초기화 되어야 한다는 차이가 존재 합니다. 

<br>

### [Q] 지역 변수 VS 전역 변수 
[A] 전역 변수는 메서드 바깥에서 선언하여 클래스 전체에서 사용가능한 변수로 메서드 메모리 영역에 저장되어 여러 메서드에서 공통적으로 사용가능 합니다. 전역 변수는 메서드 안에서 선언되어 메서드 안에서만 사용이 가능하며 스택 메모리 영역에 저장 됩니다. 

<br>

### [Q] static과 instance 차이
[A] instance 멤버는 객체를 생성한 후 사용할 수 있는 필드와 메서드를 말하며, 객체 생성 없이 사용할 수 있는 필드와 메서드를 static 멤버라고 합니다. 객체가 사라지면 멤버도 사라지는 인스턴스 멤버와 달리 클래스 멤버는 프로그램이 종료될 때까지 존재합니다. 

<br>

### [Q] Java의 main 메서드가 static인 이유
[A] Java 프로그램이 실행하기 전에 static 함수나 static 변수를 첫 단계로 메모리에 올려 프로그램을 실행시킵니다 main함수가 실행되기 위해서는 메모리에 미리 올라가야합니다. 메모리에 올라가있지 않으면, 시작점인 main() 메소드를 호출하려고 하는데 메모리에는 main이 없기 때문에 실행을 할 수가 없습니다. 따라서 main 메소드는 누군가 호출하기 전에 미리 메모리에 있어야 하기 때문에 static을 붙습니다.
즉, Java에서 main 메서드는 인스턴스를 생성하지 않고도 호출되어야 하므로 static으로 선언됩니다

<br>

### [Q] 컬렉션 프레임워크
[A] 컬렉션 프레임워크란 데이터를 쉽고 효과적으로 관리할 수 있는 표준화된 방법을 제공하는 클래스의 집합으로 크게 List, Map, Set 인터페이스로 나눌 수 있습니다. 

<br>

### [Q] List, Set, Map
[A] List는 데이터의 순서가 있고 중복이 허용됩니다. Set은 순서가 없으며 중복 또한 허용되지 않습니다. 마지막으로 Map은 키와 값을 쌍으로 저장하며 순서가 없고 키를 기준으로 중복을 불허한다는 특징이 있습니다. 


### [Q] 배열 VS 리스트
[A] 배열과 리스트는 데이터를 저장하고 관리하는데 사용되는 자료구조로 배열은 크기가 고정되며 인덱스를 통해 빠른 접근이 가능한 자료구조입니다. 리스트는 크기를 동적으로 조절할 수 있어 요소를 추가하거나 삭제에 용이하지만 요소에 접근하려면 순차적으로 탐색하여야 하기 때문에 일반적으로 배열보다 접근 속도가 느립니다. 

<br>

### [Q] Array VS ArrayList VS LinkedList
[A] 셋 모두 자료를 순차적으로 저장하는 자료구조라는 공통점이 있습니다. 먼저 Array는 크기가 고정적이지만 ArrayList와 LinkedList은 크기를 동적으로 조절할수 있다는 차이가 있습니다. 또한 Array와 ArrayList는 인덱스를 통해 요소에 직접 접근하지만 LinkedList는 순차적인 접근이 필요합니다. 따라서 데이터 조회시에는 LinkedList가 느릴 수 있습니다. 

<br>

### [Q] Generic
[A] 다양한 데이터 타입에 대해 재사용가능한 코드를 작성하는 방법을 제공하는 기능으로 데이터 타입을 하나로 지정하지 않고 사용할 때마다 범용적이고 포괄적으로 지정하여 컴파일 과정에서 에러를 방지한다. 

<br>


### [Q] String VS StringBuffer VS StringBuilder
[A] String은 수정이 불가능하므로 수정이 필요한 경우 새로운 객체를 생성해야하므로 성능이 다소 떨어질 수 있습니다. 따라서 수정이 필요할 경우 StringBuffer나 StringBuilder를 사용하는 것이 좋습니다. 두 방식은 수정이 가능하다는 공통점이 있지만 StringBuffer는 각 메서드별로 Synchronized Keyword가 존재하여, 멀티스레드 환경에서도 동기화를 지원하는 반면, StringBuilder는 동기화를 보장하지 않는다는 차이가 있습니다. 


<br>


### [Q] 객체지향 언어/객체지향 프로그래밍이란 ( OOP : Object Oriented Programming)
[A] 객체지향 프로그래밍은 데이터를 객체로 취급하고, 그 객체로부터 개발하고자 하는 특징과 기능을 뽑아와 프로그래밍하는 기법으로 캡슐화, 상속, 다형성, 추상화의 특징을 갖습니다. 

<br>

### [Q] 객체지향 설계원칙
[A] 객체지향 프로그래밍을 위해 지켜야 할 원칙으로 유지보수와 확장이 쉬운 소프트웨어를 개발하는데 도움이 되는 SOLID라고 불리는 원칙입니다. <br>
Single Responsibility PrincipleSingle 단일 책임 원칙 : 하나의 클래스는 하나의 책임만을 갖는다. <br> 
Open Closed Priciple 개방 폐쇄 원칙 : 클래스는 확장에는 열려 있고 변경에는 닫혀 있어야 한다. <br> 
Listov Substitution Priciple 리스코프 치환 원칙 : 상위 타입 객체를 하위 타입으로 바꾸어도 일관되게 동작해야 한다. <br> 
Interface Segregation Principle 인터페이스 분리 원칙 : 사용하지 않는 메서드에 의존하지 않도록 분리해야 한다. <br> 
Dependency Inversion Principle 의존 역전 원칙 : 추상화된 클래스나 인터페이스에 의존해야 하며 구현된 클래스에 의존해서는 안된다. 

<br>

### [Q] 캡슐화
[A] 캡슐화란 서로 연관 있는 속성들과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호하는 것으로 내부의 구현은 숨기고 필요한 인터페이스만 노출하여 사용자가 공개된 정보에만 접근 가능하도록 하는 객체 지향 프로그래밍의 특징 중 하나입니다. 

<br>

### [Q] 접근제한자
[A] 접근 제한자란 말 그대로 클래스 및 인터페이스 멤버에 접근을 제한하기 위한 것으로 Public, Protected, Private 3가지가 있습니다. Public은 외부 클래스에서 자유롭게 사용이 가능하며, Private는 외부 클래스에서 사용하는 것을 막고 getter/setter 메서드를 통해서 접근이 가능하도록 합니다. 마지막으로 Protected는 같은 패키지 또는 자식 클래스에서만 접근이 가능합니다. 언급한 세가지 접근제한자로 지정되지 않으면 같은 패키지 내에서만 접근이 가능한 Default 상태 입니다. 

<br>

### [Q] private 메서드 접근방법 
[A] 클래스 내부의 필드는 Private로 선언하고 해당 필드에 대해 getter/setter를 Public으로 선언하여 외부 접근을 선택적으로 제어할 수 있습니다. 

<br>

### [Q] Inner Class
[A] Inner Class는 Java와 같은 객체 지향 프로그래밍 언어에서 사용되는 중첩 클래스입니다. 내부 클래스는 다른 클래스 내부에 선언되어 있으며, 외부 클래스의 멤버 변수 및 메서드에 더 쉽게 접근하고 활용할 수 있습니다

<br>

### [Q] 상속
[A] 상속은 새로운 클래스를 정의할 때 상위 클래스의 데이터 구조와 메서드 즉, 특성을 이어받을 수 있는 개념으로 객체 지향 프로그래밍의 장점인 소프트웨어 재사용을 지원합니다. 

<br>

### [Q] 다형성
[A] 다형성이란 하나의 객체가 여러가지 타입을 가질 수 있다는 특징으로 객체를 이용해서 다양한 실행결과가 나오도록 하는 것입니다. 대표적인 예로는 오버라이딩과 오버로딩을 통한 구현이 있습니다. 

<br>

### [Q] 오버로딩 VS 오버라이딩
[A] 오버라이딩과 오버로딩은 둘 다 메서드의 이름은 같지만 때에 따라 다른 기능을 가지도록 다형성을 구현한 것 이라는 공통점을 갖습니다. 하지만 오버라이딩은 상위 클래스에서 상속 받은 메서드를 하위 클래스에서 재정의 하는 것을 의미하지만 오버로딩은 다중 정의로 매개변수의 타입, 갯수로 차이를 두어 같은 이름의 메서드를 여러개 두는 것을 의미한다는 차이가 있습니다. 

<br>

### [Q] 추상화
[A] 추상화는 구체적인 사물들의 공통적인 특징을 하나의 집합으로 다루는 것으로 핵심적인 개념과 기능을 간추려 클래스를 정의하는 것으로 구체적이고 상세한 지도를 약도로 핵심만 간략하게 표현하는 것을 예로 들 수 있습니다. 

<br>

### [Q] 인터페이스란
[A] 인터페이스란 규격을 의미하는 것으로 구현 된 것을 없는 기본 설계도 입니다. 객체화 되지 않으며 추상메서드와 상수만 가질 수 있으며 다중 구현을 지원합니다. 

<br>

### [Q] 추상 클래스 VS 인터페이스
[A] 추상클래스와 인터페이스는 개발시 규격을 만들기 때문에 모듈간의 결합도를 감소시키고 코드의 중복성을 줄여 유지보수에 용이하다는 공통점이 있습니다. 하지만 추상클래스는 상속 받은 클래스의 기능을 이용하고 확장 시키는데 목적을 두지만 인터페이스는 규격을 만들어 강제로 구현 시키는 것에 목적이 있다는 차이가 존재합니다. 또한 각각 extends와 implements 키워드를 통해 상속, 구현 되며 다중 상속은 불가능하지만 다중 구현은 가능하다는 차이점도 존재합니다. 

<br>

### [Q] Error와 Exception의 차이
[A] Error는 프로그램이 실행되는 동안 복구할 수 없는 심각한 문제를 나타냅니다. 일반적으로 시스템 레벨에서 발생하며, 프로그램 코드로 처리할 수 없습니다. Exception은 프로그램 실행 중에 예기치 않은 상황 또는 오류를 나타냅니다. 일반적으로 프로그램 코드 내에서 처리될 수 있으며, 오류가 발생하더라도 프로그램의 실행을 계속할 수 있도록 예외 처리 코드를 사용할 수 있습니다. Java에서 예외는 RuntimeException과 Checked Exception (IOException, SQLException 등)으로 구분됩니다.

<br>

### [Q] Exception 처리 방법
[A] 예외 처리 구문인 try-catch-finally 블럭을 사용하거나 메서드 선언부 끝에 throws를 선언하여 예외에 대한 처리를 메서드 호출부로 위임할 수 있습니다. 

<br>

### [Q] 동기 VS 비동기 방식
[A] 동기 방식은 작업이 순차적으로 실행되는 방식을 의미합니다. 한 작업이 시작되면 다른 작업은 대기해야 하며, 이전 작업이 완료되어야 다음 작업을 수행할 수 있습니다. 그와 반대로 비동기 방식은 작업이 순차적으로 실행되지 않고 병렬적으로 실행될 수 있는 방식을 의미합니다. 

<br>

### [Q] synchronized
[A] synchronized 키워드는 다중 스레드 환경에서 공유 자원에 대한 접근을 동기화하기 위해 사용 됩니다. 

<br>

### [Q] 프로세스, 스레드
[A] 프로세스와 스레드는 프로그램의 실행 단위로 동시에 여러 작업을 하는데 사용됩니다. 프로세스는 독립된 실행 환경을 가지며 자원을 독립적으로 관리하고 멀티스레드를 생성할 수 있습니다. 스레드는 같은 프로세스 내에서 실행되며 자원을 공유하기 때문에 동기화 관리가 필요합니다. 

<br>

### [Q] 멀티 스레드의 장점과 단점
[A] 멀티스레드 사용시 작업을 분산 처리하므로 전체 시스템 성능을 향상시켜 병렬 처리를 통해 더 빠르게 완료할 수 있습니다. 하지만 스레드간 자원 공유 및 동기화 작업은 복잡고 오류가 발생하기 쉬울 수 있으며 스레드간 경쟁 및 오버헤드로 오히려 프로그램 성능이 감소할 수도 있습니다. 

<br>

### [Q] JDBC Java Database Connectivity
[A] Java 프로그램에서 데이터베이스와 상호 작용하기 위한 표준 API로 데이터베이스에 대한 연결을 설정하고 SQL 쿼리를 실행하는데 사용됩니다. 

<br>

### [Q] API Applictation Programming Interface
[A] API란 어떤 일을 수행하기 위해 사용하는 도구나 메서드로 프로그램들이 서로 상호작용하는 것을 도와주는 매개체입니다. 자바에서는 자바를 사용하기 쉽게 구현 해 놓은 클래스 라이브러리 집합을 이야기 합니다. 

<br>

### [Q] RestfulAPI
[A] HTTP 통신에서 CRUD 요청을 리소스와 메서드로 표현하여 특정한 형태로 전달하는 방식으로 자원(URI), 요청 방식(GET, POST, UPDATE, DELETE), 자원의 표현 형태( JSON, XML)로 구성됩니다. 

<br>

### [Q] Get VS Post 방식
[A] Get 방식은 URL에 요청 정보를 붙여서 데이터를 조회 하므로 POST 방식보다 보안상 취약합니다. 하지만 데이터나 계산 결과를 임시로 저장하는 캐싱을 사용할 수 있어 빠르다는 장점이 있습니다. Post 방식은 요청 정보를 HTTP 패킷의 Body안에 숨겨서 서버로 전송하여 데이터를 등록하므로 GET 방식보다 보안상 안전합니다. 

<br>

### [Q] Cookie VS Session
[A] 쿠키는 Client PC에 저장되며 유효 기간을 따로 설정할 수 있어 라우저가 종료되어도 유지 될 수 있습니다. Client PC에 저장되어 있어 속도는 빠르지만 데이터 노출과 조작 위험에 취약하여 보안성은 세션에 비해 낮습니다. 이와 달리 세션은 웹 서버에 저장되므로 쿠키보다 안전하지만 속도는 상대적으로 느립니다. 또한 웹 서버에 저장되므로 브라우저가 종료될 경우 세션은 삭제됩니다. 

<br>

### [Q] jsp, servlet
[A] 서블릿이란 웹페이지를 동적으로 생성하기 위한 서버측 프로그램으로 JSP란 HTML 코드에 JAVA 코드를 넣어 동적 웹페이지를 생성하는 웹 어플리케이션 도구로 JSP가 실행되면 자바 서블릿으로 변환되며 웹어플리케이션 서버에서 동작되면서 필요한 기능을 수행하고 생성된 데이터를 웹페이지와 함께 클라이언트로 응답합니다. 

<br>

### [Q] model1 과 model2 의 차이점
[A] Model1은 View와 Controller를 JSP에서 모두 구현하는 구조를 가지고 있습니다.사용자의 요청처리와 요청에 대한 응답처리를 JSP에서 모두 표현하는 구조로 흐름이 단순하기 때문에 개발이 쉽다는 장점이 있습니다. Model2는 View와 Controller가 분리된 구조를 가지고 있어 클라이언트의 요청을 처리, 흐름제어를 하면서 필요시 Model과 상호작용을하는 Controller는 Servlet에서 담당하고 사용자 인터페이스를 보여주는 View는 JSp에서 담당하고 있다는 차이가 있습니다.

<br>

### [Q] 어노테이션
[A] 프로그램에게 추가적인 정보를 제공해주는 메타데이터로 자바에서 사용될 때의 어노테이션은 코드 사이에 주석처럼 쓰여서 특별한 의미, 기능을 수행하도록 하는 기술이다. <br>
ex1) @Component <br>
개발자가 생성한 Class를 Spring의 Bean으로 등록할 때 사용하는 Annotation입니다. Spring은 해당 Annotation을 보고 Spring의 Bean으로 등록합니다. <br>
ex2) @Bean <br>
@Bean Annotation은 개발자가 제어가 불가능한 외부 라이브러리와 같은 것들을 Bean으로 만들 때 사용합니다. <br>
ex3) @Autowired <br>
Spring Framework에서 Bean 객체를 주입받기 위한 방법은 크게 아래의 3가지가 있습니다. Bean을 주입받기 위하여 @Autowired 를 사용합니다. Spring Framework가 Class를 보고 Type에 맞게(Type을 먼저 확인 후, 없으면 Name 확인) Bean을 주입합니다. <br>
<br>

