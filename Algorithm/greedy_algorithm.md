# Greedy Algorithm

### 정의
#
* 최적해를 구하기 위해 각 단계에서 가장 좋아보이는 선택을 하는 알고리즘
* 선택은 그 순간에는 최적일 수 있지만, 그 선택이 전체적으로 최적해를 보장하지는 않을 수 있음
* 탐욕 알고리즘은 각 단계에서 지역적으로 최선의 선택을 하는 것이며, 이를 반복하여 최종적으로 전체적으로 좋은 결과를 얻는 것을 목표로 함

<br>

### 특징
#
* 문제의 성질이 동일하게 보존되고, 같은 전략을 반복적으로 사용 가능할 때 적용
* 앞의 선택이 이후의 선택의 영향을 주지 않는 조건
* 문제 최종 해결 방법이 부분 문제에 대한 해결 방법과 동일한 조건일 때 사용

**장점**
* 단순하고 직관적인 방법으로 구현 가능
* 대부분의 경우 적은 비용으로 빠른 실행 속도를 가짐
  
**단점**
* 항상 최적해를 보장하지 않음 때로는 지역적으로 최적인 선택을 계속 수행하다가 전체적으로는 최적이 아닌 결과를 도출할 수 있음

<br>

### 동작방식
#
1. **선택 단계(Selection Phase)** <br>
각 단계에서 최적의 선택을 찾아 선택, 이 선택은 그 순간에는 최적으로 보이는 것을 의미
1. **가능성 검증 단계(Feasibility Checking Phase)** <br>
선택된 항목이나 해를 현재 문제의 조건에 맞는지 검증 
1. **해 검증 단계(Solution Verification Phase)** <br>
전체 문제에 대한 해가 완성되었는지 검증하고, 만족하는지 확인

<br>

### 예시
#
1. **거스름돈 문제** <br>
   가장 큰 동전부터 차례대로 거스름돈을 주는 경우. 이 때 동전의 가치가 서로 배수 관계일 때는 탐욕 알고리즘으로 최적해를 구할 수 있음.

2. **작업 스케줄링 문제** <br>
   여러 작업이 있을 때, 작업의 끝나는 시간을 최소화하도록 탐욕적으로 선택하는 알고리즘.

3. **부분 배낭 문제(Fractional Knapsack Problem)** <br>
    무게 제한이 있는 배낭에 물건을 담을 때, 단가가 높은 물건부터 선택하는 알고리즘.

<br>

### 상세 예시 : 탐욕 알고리즘을 적용한 거스름돈 문제
#
[Q] 790원을 거슬러 줘야 할 때 거스름 돈의 종류는 500원, 100원, 50원, 10원인 경우

[A] 500 * 1, 100 * 2, 50 * 1, 10 *4
1. 가장 큰 가치인 500원 동전 1개를 거슬러 준다.
2. 남은 금액 290원에 대해 가장 큰 가치인 100원 동전 2개를 거슬러 준다.
3. 남은 금액 90원에 대해 가장 큰 가치인 50원 동전 1개를 거슬러 준다.
4. 남은 금액 40원에 대해 가장 큰 가치인 10원 동전 4개를 거슬러 준다.

위와 같이 각 단계에서 가장 큰 가치의 동전을 선택하여 거슬러 주면 최종적으로 최소 동전 개수로 거스름돈을 줄 수 있다. 

<br>

### 복잡도
#
* 탐욕 알고리즘의 복잡도를 분석하는 것은 알고리즘의 성능을 평가하고 문제에 대한 적합성을 판단하는 데 중요
* 최적해를 보장하지 않을 수 있는 탐욕 알고리즘이지만, 어떤 경우에는 실제로는 효율적인 해결책을 제공할 수 있기 때문에 그 활용도는 여전히 높음
  
**시간 복잡도**
- 각 단계에서 필요한 계산의 횟수에 의해 결정
- 주어진 문제의 특성에 따라 시간 복잡도가 달라질 수 있음
- ex) 거스름돈 문제
  - 동전의 개수를 n이라고 하면, 동전의 개수에 비례하는 횟수로 반복문이 실행
  - 시간 복잡도는 O(n)

**공간 복잡도**
- 추가적인 메모리 사용에 의해 결정
- 탐욕 알고리즘은 선택한 항목이나 해를 저장하는 공간을 필요로 할 수 있으며 이는 선택에 따라 변할 수 있음
- ex) 거스름돈 문제
  - 추가적인 메모리 공간을 사용하지 않고, 주어진 입력과 동전의 개수만을 다룸
  - 공간 복잡도는 O(1)



### [Programmers][level 1] 체육복 [문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42862) 
### 문제 설명

<p>점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.</p>

<p>전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요.</p>

<h5>제한사항</h5>

<ul>
<li>전체 학생의 수는 2명 이상 30명 이하입니다.</li>
<li>체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.</li>
<li>여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.</li>
<li>여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다.</li>
<li>여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.</li>
</ul>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>n</th>
<th>lost</th>
<th>reserve</th>
<th>return</th>
</tr>
</thead>
        <tbody><tr>
<td>5</td>
<td>[2, 4]</td>
<td>[1, 3, 5]</td>
<td>5</td>
</tr>
<tr>
<td>5</td>
<td>[2, 4]</td>
<td>[3]</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>[3]</td>
<td>[1]</td>
<td>2</td>
</tr>
</tbody>
      </table>

### 풀이
```
import java.util.HashSet;

class Solution {
    public int solution(int n, int[] lost, int[] reserve) {
      // 일단 모든 학생이 수업을 들을 수 있는 상태로 시작
      int answer = n - lost.length; 
        
      HashSet<Integer> lostSet = new HashSet<>();
      HashSet<Integer> reserveSet = new HashSet<>();
        
      for (int l : lost) {
         // 체육복을 도난당한 학생들을 HashSet에 추가
         lostSet.add(l); 
      }
        
      for (int r : reserve) {
         if (lostSet.contains(r)) {
            // 여벌 체육복을 가져왔지만 체육복을 도난당한 경우
            lostSet.remove(r);
            answer++;
         } else {
            // 여벌 체육복을 가져온 학생들을 HashSet에 추가
            reserveSet.add(r); 
         }
      }
        
      for (int r : reserveSet) {
         if (lostSet.contains(r - 1)) {
            // 바로 앞 번호의 학생이 체육복을 도난당한 경우
            lostSet.remove(r - 1);
            answer++;
         } else if (lostSet.contains(r + 1)) {
            // 바로 뒷 번호의 학생이 체육복을 도난당한 경우
            lostSet.remove(r + 1);
            answer++;
         }
      }
        
      return answer;
    }
}

```
